
* This is mine emacs doc
** and i will write all keycommand and any need remember things
The <Tab> can expand/consrict

* The config
** basic config
menu-bar-mode 0 this can trun off menu bar
tool-bar-mode 0 this can trun off tool bar
scroll-bar-mode 0 this can trun off scroll bar
column-number-mode 0 this can display current colum,example (15,4)
global-display-line-numbers-mode
setq display-line-numbers-type 'relative this enable relative line

b b main
F u
b c 一个新分支
c c messages C-c C-c
f a 
r e 到main
第一阶段：准备工作 (Start)
在你开始写任何新功能之前，必须保证你的地基是新的。

切回主分支：b b -> main

拉取最新代码：F u (Pull from upstream)

原理：这一步等于 Fetch + Merge。确保你的 main 和服务器的 origin/main 是一模一样的。

第二阶段：开发 (Development)
永远不要在 main 上直接改代码，永远新建分支。

新建并切换分支：b c -> 输入 feature/xxx

写代码、提交：c c -> 写 Message -> C-c C-c (重复 N 次)

第三阶段：同步与整理 (The Rebase Step) —— 这是最关键的一步
假设你写代码的一周里，服务器上的 origin/main 已经更新了（可能你在其他电脑提交过，或者同事提交过）。你需要把你的代码“搬”到最新的进度上去。

获取最新情报：f a (Fetch all)

注意：这时候你的 main 落后了，origin/main 更新了。但不用管本地的 main，我们直接操作 feature。

变基 (Rebase)：

保持在 feature 分支。

输入 r e (Rebase elsewhere)。

选择 origin/main (注意：选红色的远程分支)。

原理：这步操作会把你的 feature 修改“剪切”下来，贴到最新的 origin/main 屁股后面。

如果有冲突：e (Ediff) 解决 -> r r (Continue)。

第四阶段：合并与推送 (Finish)
现在你的 feature 分支已经是最新的，且基于最新的 origin/main，合并回去就是“快进模式”（直线）。

切回主分支：b b -> main

合并分支：m m -> 选择 feature/xxx

现象：因为你刚才 Rebase 过了，这里不会产生 Merge Commit，指针直接“滑”过去，非常丝滑。

推送主分支：P p (Push main to origin/main)

第五阶段：打扫战场 (Cleanup)
删除功能分支：b k -> feature/xxx

结果：本地干净了，远程也干净了。回到第一阶段。

纠正你的一个小误区
你刚才说：“然后推送，推送完后在将origin/main与本地的main merge一下”

这里的逻辑稍微有点乱。

如果你是按上面的“独行侠模式”：你是在本地合并完（第 8 步），然后直接推送到服务器（第 9 步）。你不需要再 Pull/Merge 了，因为你推上去的内容就是最新的。

如果你是按“团队模式” (Pull Request)：

你 Rebase 完 feature 分支。

你 Push feature 分支到服务器 (P p)。

你去 GitHub/GitLab 网页上点 "Merge Pull Request"。

这时候服务器的 origin/main 变了。

你回到本地，切换到 main，执行 F u (Pull)，把你刚才在网页上合并的结果拉下来。

总结你的口诀
你的理解基本正确，优化后的口诀是：

Pull (main 更新)

Branch (干活)

Fetch (看服务器变没变)

Rebase to origin/main (把我的活儿垫在最新的进度后面)

Merge (把我的活儿合进本地 main)

Push (把本地 main 同步给服务器)

这样重复，你的 Git 历史就是一条完美的直线，看起来就像是一个顶级工程师写出来的。
